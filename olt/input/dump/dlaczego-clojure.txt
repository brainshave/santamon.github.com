Dlaczego Clojure?

index:false
 
* Clojure

 *Clojure* http://clojure.org jest nowym językiem programowania
 mającym dwa główne techniczne założenia:

# Jest językiem *goszczonym*, tzn. działa na istniejącej maszynie wirtualnej.
# Jest *lispem*.

 To, co Clojure wprowadza *nowego* zostanie opisane niżej.

** Gość na maszynach wirtualnych

 Clojure z założenia jest językiem bez własnego środowiska
 uruchomieniowego. Zamiast tego, integruje się z istniejącymi
 maszynami wirtualnymi (MW). W tym momencie istnieją dwie implementacje: na
 JVM http://github.com/clojure/clojure i .NET http://github.com/richhickey/clojure-clr.

 Integracja dotyczy:

- generowania *natywnego* dla danej MW *kodu bajtowego* (co znaczy, że szybkość programów będzie porównywalna z innymi językami na te platformy, np. Java czy C#),
- użycia *rodzimego modelu obiektowego* (w przeciwieństwie np. {J/Iron}Ruby'ego i {J/Iron}Pythona, które wprowadzają swój własny model obiektowy ponad natywnym)

 Drugi punkt ma jedną ważną konsekwencję: Programy w Clojure i
 C#/Javie mogą na danej MW współpracować w dwie strony bez pisania
 warstwy pośredniczącej. Na przykład program w Javie może używać
 biblioteki napisanej w Clojure i w drugą stronę. Znaczy to także, że
 wszystkie dotychczas powstałe biblioteki dla danej MW są dla nas
 dostępne.

** lisp z małej litery

 Clojure jest lispem, tzn. jednym z wielu dialektów Lispa http://pl.wikipedia.org/wiki/Lisp. Najbardziej rozpoznawalną cechą
 tego języka jest konstrukcja kodu: Kod programu w Lispie jest listą
 (jako struktura danych). Z kolei sam Lisp jest językiem, w którym z
 łatwością operuje się na listach. Umożliwia to pisanie programów
 piszących programy (przed kompilacją kodu można go przetworzyć w
 samym programie) co jest zasadniczą ideą *metaprogramowania* http://pl.wikipedia.org/wiki/Metaprogramowanie.

 Metaprogramownie w Lispie i Clojure pozwala na:

# optymalizację i skracanie kodu w sytuacjach, gdy nie jest możliwe użycie zwykłych funkcji,
# umieszczanie istniejącego kodu w otoczeniu zmieniającym jego sens,
# tworzenie *nowych konstrukcji języka* _bez ingerencji w kompilator_,
# pisanie zupełnie nieczytelnych i błędnych programów ;\-).

 Myślę, że nie wyczerpałem wszystkich przykładów ale szczególnie ważny
 jest punkt trzeci. W popularnych językach (C++, Java, C#) o nowe
 konstrukcje trzeba prosić ich twórców i później na nie
 czekać. Rozwiązaniem tymczasowym może być wstępne przetwarzanie kodu
 przez zewnętrzny program przed kompilacją. Komplikuje to oczywiście
 proces kompilacji (także spowalnia go), zwiększa zależności w naszym
 projekcie i zrywa kompatybilność z innym kodem.

 Rozwiązanie w Lispie jest eleganckie i nie ma wad wymienionych
 powyżej. Metaprogramowanie zasługuje na osobny wpis i taki wkrótce
 się tutaj pojawi.

