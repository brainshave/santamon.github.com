Dlaczego Clojure?

date: 2010-11-13
index: false

 Patrząc na historię języków programowania można zaobserwować, że co
 kilka lat twórcy oprogramowania rewidują swoje narzędzia. Weryfikują,
 czy te dotychczas przez nie używane spełniają obecne wymogi stawiane
 im w pracy. Efektami tych rewizji są nowe narzędzia: biblioteki i
 języki. Zacznijmy od bibliotek.

=> Na potrzeby przykładu załóżmy, że żyjemy w smutnym świecie nieznającym jeszcze tablic ;\-)

 Kiedy programiście na potrzeby jego projektu brakuje jakiejś
 konstrukcji w języku -- powiedzmy zwykłej *tablicy* -- pisze na swoje
 potrzeby pierwszą implementację. Początkowo jest to wersja
 obsługująca jeden typ danych, pisana na szybko, z nagłej
 potrzeby. Używa dostępnych mu konstrukcji języka, np. wyciąganie
 elementów odbywa się z użyciem metody @pobierz(numer)@.
 
 Potem dochodzi do wniosku, że jego tablice mogą przydać się także w
 innych projektach. Szlifuje swoją implementację i tworzy z niej
 *bibliotekę*. Z czasem staje się ona tak popularna, że używa jej
 niemal każdy programista. Każdy z nich wchłonął już mentalnie zasadę
 działania tablic i sposób ich użycia. W tym momencie można
 powiedzieć, że tablice stały się częścią świadomości zbiorowej.

 Teraz wkraczają twórcy języków. Powstaje pierwszy eksperymentalny
 język, implementujący tablice w kompilatorze. Jego twórcy najpierw są
 krytykowani za rozrzutność i komplikowanie języka. Przecież nie każdy
 potrzebuje tablic. Resztę skrócę: historia kończy się tak, że każdy
 język ma tablice.

 Można więc zauważyć, że nowe języki (albo nowe wersje starych)
 /agregują/ konstrukcje tak potrzebne programistom, że stają się
 częścią ich mentalności. W tym momencie przedstawię Clojure, po czym
 wrócę do tego tematu.

* Clojure
 
 *Clojure* http://clojure.org jest nowym językiem programowania
 mającym dwa główne techniczne założenia:

# Jest językiem *goszczonym*, tzn. działa na istniejącej maszynie wirtualnej.
# Jest *lispem*.

 To, co Clojure wprowadza *nowego* zostanie opisane niżej.

** Gość na maszynach wirtualnych

 Clojure z założenia jest językiem bez własnego środowiska
 uruchomieniowego. Zamiast tego, integruje się z istniejącymi
 maszynami wirtualnymi (MW). W tym momencie istnieją dwie implementacje: na
 JVM http://github.com/clojure/clojure i .NET http://github.com/richhickey/clojure-clr.

 Integracja dotyczy:

- generowania *natywnego* dla danej MW *kodu bajtowego* (co znaczy, że szybkość programów będzie porównywalna z innymi językami na te platformy, np. Java czy C#),
- użycia *rodzimego modelu obiektowego* (w przeciwieństwie np. {J/Iron}Ruby'ego i {J/Iron}Pythona, które wprowadzają swój własny model obiektowy ponad natywnym)

 Drugi punkt ma jedną ważną konsekwencję: Programy w Clojure i
 C#/Javie mogą na danej MW współpracować w dwie strony bez pisania
 warstwy pośredniczącej. Na przykład program w Javie może używać
 biblioteki napisanej w Clojure i w drugą stronę. Znaczy to także, że
 wszystkie dotychczas powstałe biblioteki dla danej MW są dla nas
 dostępne.

** lisp z małej litery

 Clojure jest lispem, tzn. jednym z wielu dialektów Lispa http://pl.wikipedia.org/wiki/Lisp. Najbardziej rozpoznawalną cechą
 tego języka jest konstrukcja kodu: Kod programu w Lispie jest listą
 (jako struktura danych). Z kolei sam Lisp jest językiem, w którym z
 łatwością operuje się na listach. Umożliwia to pisanie programów
 piszących programy (przed kompilacją kodu można go przetworzyć w
 samym programie) co jest zasadniczą ideą *metaprogramowania* http://pl.wikipedia.org/wiki/Metaprogramowanie.

 Metaprogramownie w Lispie i Clojure pozwala na:

# optymalizację i skracanie kodu w sytuacjach, gdy nie jest możliwe użycie zwykłych funkcji,
# umieszczanie istniejącego kodu w otoczeniu zmieniającym jego sens,
# tworzenie *nowych konstrukcji języka* _bez ingerencji w kompilator_,
# pisanie zupełnie nieczytelnych i błędnych programów ;\-).

 Myślę, że nie wyczerpałem wszystkich przykładów ale szczególnie ważny
 jest punkt trzeci. W popularnych językach (C++, Java, C#) o nowe
 konstrukcje trzeba prosić ich twórców i później na nie
 czekać. Rozwiązaniem tymczasowym może być wstępne przetwarzanie kodu
 przez zewnętrzny program przed kompilacją. Komplikuje to oczywiście
 proces kompilacji (także spowalnia go), zwiększa zależności w naszym
 projekcie i zrywa kompatybilność z innym kodem.

 Rozwiązanie w Lispie jest eleganckie i nie ma wad wymienionych
 powyżej. Metaprogramowanie zasługuje na osobny wpis i taki wkrótce
 się tutaj pojawi.

