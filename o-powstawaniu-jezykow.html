<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="media/bug-inv.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Long-standing Bug" href="atom.xml" />
    <!-- <link rel="stylesheet" href="media/fonts.css" /> -->
    <link rel="stylesheet" href="media/makeblog.css" />
    <link rel="stylesheet" href="media/common.css" />
    <link rel="stylesheet" href="media/article.css" />
    <title>O powstawaniu języków (tytuł roboczy)</title>
    <!-- work around IE not handling properly unknown tags -->
    <!-- suggested here: http://diveintohtml5.org/semantics.html -->
    <script>
      document.createElement("article");
      document.createElement("nav");
      document.createElement("aside");
      document.createElement("footer");
      document.createElement("date");
    </script>
    <script src="media/hyphenator.js" type="text/javascript"></script>
  </head>
  <body>
    <div id="main_wrapper">
      <div id="header">
	<div id="sw">
	  <a href="index.html">
	    <img src="media/s-w-small.png" alt="S/W" />
	  </a>
	</div>
	<nav id="menu">
	  <a href="archive.html">Archiwa</a>,
	  <a href="info.html">Info</a>
	</nav>
      </div>
      <div id="latest">
	<time id="latest_text">sobota, 25 grudzień 2010</time>
	<article class="hyphenate">
	  <h1>O powstawaniu języków (tytuł roboczy)</h1>
	  <p>Patrząc na historię języków programowania można zaobserwować, że co
kilka lat twórcy oprogramowania rewidują swoje narzędzia. Weryfikują,
czy te dotychczas przez nich używane spełniają obecne wymogi stawiane
im w pracy. Efektami tych rewizji są nowe narzędzia: biblioteki i
języki. Zacznijmy od bibliotek.
</p><p class="makeblog_box makeblog_box_right">Na potrzeby przykładu załóżmy, że żyjemy w smutnym świecie nieznającym jeszcze tablic ;-)
</p><p>Kiedy programiście na potrzeby jego projektu brakuje jakiejś
konstrukcji w języku &mdash; powiedzmy zwykłej <strong>tablicy</strong> &mdash; pisze na swoje
potrzeby pierwszą implementację. Początkowo jest to wersja
obsługująca jeden typ danych, pisana na szybko, z nagłej
potrzeby. Używa dostępnych mu konstrukcji języka, np. wyciąganie
elementów odbywa się z użyciem metody <code>pobierz(numer)</code>.
</p><p>Potem dochodzi do wniosku, że jego tablice mogą przydać się także w
innych projektach. Szlifuje swoją implementację i tworzy z niej
<strong>bibliotekę</strong>. Z czasem staje się ona tak popularna, że używa jej
niemal każdy programista. Każdy z nich wchłonął już mentalnie zasadę
działania tablic i sposób ich użycia. W tym momencie można
powiedzieć, że tablice stały się częścią świadomości zbiorowej.
</p><p>Teraz wkraczają twórcy języków. Powstaje pierwszy eksperymentalny
język, implementujący tablice w kompilatorze. Jego twórcy są
krytykowani za rozrzutność i komplikowanie języka &mdash; przecież nie
każdy potrzebuje tablic!
</p><p>Najpierw pali się na stosach heretyków i czarownice. Później
przyznaje się im rację. Resztę skrócę: historia kończy się tak, że
każdy język ma tablice.
</p><h2>Małe podsumowanie</h2><p>Można zauważyć, że nowe języki (albo nowe wersje starych) <em>agregują</em>
konstrukcje tak potrzebne programistom, że stają się częścią ich
mentalności.
</p><p>Często zdarza się również, że zanim konstrukcja pojawi się w jakimś
języku przechodzi przez etap bycia wzorcem projektowym.
</p><h2>Po co powstają nowe języki, biblioteki, maszyny wirtualne, itp.?</h2><p>Zawsze po to, by programista mógł zrobić więcej pisząc mniej
kodu. Kiedy okazuje się, że większość kodu aplikacji to tylko
otoczka potrzebna do działania programu to znaczy, że używamy złych
narzędzi. 
</p><h2>Nowe problemy i rozwiązania</h2><h3>1. Programowanie współbieżne</h3><p>Prawdą jest, że kompilatory zawsze były w tyle za sprzętem. Przez
lata pomijano w ogóle fakt, że w pewnym momencie przestaną pojawiać
się szybsze procesory. W tym momencie mamy sytuację, gdzie
producenci sprzętu mówią "Nie damy wam już szybszych procesorów ale
możemy dać ich więcej.". Po prostu zysk wydajności przy zwiększaniu
taktowania jest niewspółmierny ze wzrostem zużycia energii. W
takich okolicznościach odpowiedzialność za przyspieszenie programu
spada na programistę.
</p><p>Tu pojawia się problem. Aplikacje (szczególnie te użytkowe, dla
ludu) były pisane na jeden procesor, w sposób zupełnie ignorujący
problem wykorzystania na raz ich większej ilości. Działo się tak
chociażby dlatego, że <strong>programowanie równoległe jest</strong> (uważane za)
<strong>trudne</strong>.
</p><p>A gdyby sformułować to inaczej, np.: programowanie równoległe jest
trudne <strong>bez odpowiednich abstrakcji</strong>? Tak jak tablica jest
abstrakcją dostępu do bloków pamięci możliwe jest stworzenie
abstrakcji ułatwiających pisanie algorytmów wykonujących się
współbieżnie.
</p><p>Istnieje wielkie zapotrzebowanie na narzędzia (kompilatory, języki,
maszyny wirtualne, biblioteki) ułatwiające programowanie
równoległe. W tym momencie nie jest już to "atrakcyjny ficzer" a
mus. Musem jest także zmiana mentalności programistów.
</p><h3>1 1/2. Obiektowe a funkcyjne</h3><p>OOP to bardzo dobry model do projektowania oprogramowania. W
intuicyjny sposób oddaje to jak człowiek postrzega świat albo
urządzenia. Mamy obiekty, na których wykonujemy odpowiednie im
czynności, np. <code>Samochód.zapal()</code> albo <code>Skała.przesuń()</code>. Po
wywołaniu tych metod samochód zapala a skała się
przesuwa. Moment. Nie. Człowiek przesunie.
</p><p>Można powiedzieć, że programowanie funkcyjne od obiektowego różni
się tym co <code>Samochód.zapal()</code> od <code>przesuń(Skała)</code>.
</p><p>Dokładniej, można powiedzieć, że pisząc obiektowo opisuje się co
można zrobić z czym. Pisząc funkcyjnie mówimy jak przetworzyć coś
na coś. Wynikiem funkcji <code>przesuń</code> będzie nowa skała, w innym
miejscu. Stara skała siedzi w starym miejscu i ma się dobrze.
</p><p>O ile nie ma sensu zapalać na raz samochodu przez wiele osób
(wyobraźmy sobie trzystu chłopa w jednej kabinie łapiących za
kluczyk) to może mieć sens przesunięcie skały na raz w wiele
miejsc. Np. skała to pionek w programie szachowym, w którym chcemy,
by wszystkie możliwe rozwiązania były obliczane równolegle.
</p><p>Dzięki temu, że oryginalna skała pozostała na swoim miejscu, ktoś
inny (wątek) może w tym samym czasie swobodnie "przesunąć" ją w
inne. Jeśli byłby to obiekt w rozumieniu tradycyjnego OOP ze
zmiennymi polami X i Y oznaczającymi pozycję, musielibyśmy sami
dbać o sklonowaniu go dla każdego wątku. Język funkcyjny w ogóle
nie pozwoliłby na modyfikację tych pól, sam za nas skopiowałby
obiekt. Zdejmuje zatem z nas obowiązek pamiętania o tym, wyklucza
również możliwość wystąpienia błędu przez zapomnienie o klonowaniu
w jakimś miejscu.
</p>
	</article>
      </div>
      <footer>
	&copy; 2010 Szymon Witamborski
      </footer>
    </div>
  </body>
</html>
