<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long-standing Bug</title> 
  <link href="http://longstandingbug.com" rel="self" />
  <updated>2011-04-04T18:09:24Z</updated>
  <author> 
    <name>Szymon Witamborski</name>
  </author>
  <id>http://longstandingbug.com/./atom.xml</id>
  
  <entry>
    <title>Zdarzenia w GUI FTW!</title>
    <link href="http://longstandingbug.com/zdarzenia-guiftw.html" rel="alternate" />
    <id>http://longstandingbug.com/zdarzenia-guiftw.html</id>
    <updated>2011-04-04T00:00:00Z</updated>
    <published>2011-04-04T00:00:00Z</published>
    <content type="html">&lt;p&gt;Tradycyjnie w Swingu bądź SWT żeby obsłużyć zdarzenie musimy utworzyć
nową implementację jakiegoś interfejsu, np. &lt;code&gt;MouseListener&lt;/code&gt; a potem
go zarejestrować w obiekcie, którego zdarzenia nas interesują.
&lt;/p&gt;&lt;pre&gt;button.addMouseListener(new MouseListener() {
    public void mouseClicked(MouseEvent event) {
        //... obsługa zdarzenia
    }
    public void mouseEntered(MouseEvent event) {
        //... obsługa zdarzenia
    }
    public void mouseExited(MouseEvent event) {
        //... obsługa zdarzenia
    }
    public void mousePressed(MouseEvent event) {
        //... obsługa zdarzenia
    }
    public void mouseReleased(MouseEvent event) {
        //... obsługa zdarzenia
    }
});
&lt;/pre&gt;&lt;p&gt;Jeśli obchodzi nas tylko jedno zdarzenie, wygodnie jest dziedziczyć po
klasie &lt;code&gt;MouseAdapter&lt;/code&gt;, która implementuje wszystkie metody jako puste,
wystarczy więc zaimplementować jedną metodę:
&lt;/p&gt;&lt;pre&gt;button.addMouseListener(new MouseAdapter() {
    public void mouseClicked(MouseEvent event) {
        //... obsługa zdarzenia
    }
});
&lt;/pre&gt;&lt;p&gt;Jak widać, trzeba się sporo opisać zanim dotrze się do miejsca, gdzie
umieści się właściwy kod, nawet w wersji z adapterem. Jeśli jest
możliwe napisanie kodu krótszego i przynajmniej tak samo dobrze
wyrażającego co chcemy osiągnąć to moim zdaniem warto.
&lt;/p&gt;&lt;h2&gt;Jak to wygląda w GUI FTW!?&lt;/h2&gt;&lt;p&gt;Obsługę zdarzeń wrzucamy do arkuszy stylów. Wygląda to tak jak każda
inna właściwość (tekst, kolor, itd.) poza tym, że nazwą właściwości
jest specyfikacja zdarzenia a wartością jest funkcja która je obsłuży.
Dzięki temu zyskujemy również na wszystkich zaletach arkuszy stylów,
np. można obsłużyć zdarzenia z wielu obiektów na raz.
&lt;/p&gt;&lt;pre&gt;(stylesheet [[:cos :drugie-cos] [:text "Coś!"
                                 &amp;lt;spec-zdarzenia&amp;gt; &amp;lt;funkcja&amp;gt;]])
&lt;/pre&gt;&lt;h3&gt;Specyfikacja zdarzenia&lt;/h3&gt;&lt;p&gt;GUI FTW! musi znać dwie rzeczy: nazwę interfejsu *Listener i jedną
metodę do zaimplementowania &amp;mdash; nazwę zdarzenia. Trzeba to podać w
takiej formie:
&lt;/p&gt;&lt;pre&gt;&amp;lt;nazwa interfejsu&amp;gt;+&amp;lt;nazwa metody&amp;gt;
&lt;/pre&gt;&lt;p&gt;Czyli np. &lt;code&gt;mouse+mouse-clicked&lt;/code&gt; albo
&lt;code&gt;action+action-performed&lt;/code&gt;. Odpada dzięki temu spora część zbędnego
kodu z pierwszego przykładu. Widać coś jeszcze: np. w
&lt;code&gt;mouse+mouse-clicked&lt;/code&gt; słowo &lt;code&gt;mouse&lt;/code&gt; powtarza się. Ponieważ występuje
to dość często dodałem skrót: jeśli napiszemy &lt;code&gt;++&lt;/code&gt; zamiast &lt;code&gt;+&lt;/code&gt; możemy
pozbyć się zbędnego słowa.
&lt;/p&gt;&lt;pre&gt;mouse++clicked -&amp;gt; mouse+mouse-clicked -&amp;gt; MouseListener.mouseClicked
&lt;/pre&gt;&lt;h4&gt;Dlaczego nie uniwersalne &lt;code&gt;on-click&lt;/code&gt; albo &lt;code&gt;on-mouse-over&lt;/code&gt;?&lt;/h4&gt;&lt;p&gt;Takie rozwiązanie na pewno byłoby intuicyjne dla osób
początkujących. Nie widzę jednak sensu gdy &lt;code&gt;mouse++clicked&lt;/code&gt; jest
wystarczająco wymowne. Poza tym powodowałoby zwiększenie kodu w GUI
FTW! specyficznego dla bibliotek, które obsługuje (w tym momencie
Swing i SWT).
&lt;/p&gt;&lt;p&gt;Dzięki temu, że GUI FTW! wymaga podania nazwy interfejsu i metody,
możliwa jest obsługa zdarzeń wymyślonych przez programistę na poziomie
równym z tymi wbudowanymi w Swing bądź SWT.
&lt;/p&gt;&lt;h3&gt;Funkcja obsługująca&lt;/h3&gt;&lt;p&gt;W tym momencie funkcja obsługująca zdarzenie ma jeden argument:
zdarzenie, które wystąpiło. Może to być zarówno funkcja anonimowa jak
i nazwa funkcji zdefiniowanej w innym miejscu.
&lt;/p&gt;&lt;h2&gt;Przykład&lt;/h2&gt;&lt;p&gt;Rozwinę lekko przykład z poprzedniego wpisu (utrzymując poziom
hellołłorldowy). Dla przypomnienia struktura interfejsu:
&lt;/p&gt;&lt;pre&gt;(def window 
  (swing
    [JFrame [*id :okno-ftw]
     [JButton [*id :przycisk-omg]]]))
&lt;/pre&gt;&lt;p&gt;Do arkusza styli dodamy obsługę zdarzenia:
&lt;/p&gt;&lt;pre&gt;(def sheet
 (stylesheet
  [:okno-ftw] [:title "GUI FTW!"
               :size ^unroll (300 200)
               :visible true]
  [:przycisk-omg] [:text "To jest przycisk!"
                   :mouse++clicked
                   (fn [event]
                    (JOptionPane/showMessageDialog nil "GUI FTW!"))]))
&lt;/pre&gt;&lt;p&gt;&lt;img src="gui-ftw-pierwsza-akcja.png" alt="Prosty przykład podpięcia akcji pod przycisk" /&gt;
&lt;/p&gt;&lt;p&gt;Pełny kod tego przykładu znajduje się &lt;a href="https://github.com/santamon/GUIFTW/blob/master/src/guiftw/examples/swing/basic.clj"&gt;tutaj&lt;/a&gt;.
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Niech się stanie GUI FTW!</title>
    <link href="http://longstandingbug.com/niech-sie-stanie-gui-ftw.html" rel="alternate" />
    <id>http://longstandingbug.com/niech-sie-stanie-gui-ftw.html</id>
    <updated>2011-03-20T00:00:00Z</updated>
    <published>2011-03-20T00:00:00Z</published>
    <content type="html">&lt;p&gt;Ponieważ bardzo lubię programowanie deklaratywne brakowało mi od dawna
czegoś deklaratywnego do tworzenia GUI. Kod tworzący GUI jest zawsze
bardzo nudny i powtarzalny: "stwórz obiekt, ustaw jego tekst, ikonę,
dodaj akcję na klik (wcześniej stwórz obiekt implementujący
odpowiedniego listenera), ew. stwórz obiekty-dzieci, bla bla bla".
&lt;/p&gt;&lt;p&gt;Projektanci stron internetowych od początku mają do dyspozycji HTML i
CSS, które są jak najbardziej deklaratywne w swojej naturze. Dodatkowo
treść określa się osobno od tego jak ma wyglądać. Model ten zaczyna
wychodzić poza przeglądarki, np. XAML w .NET albo pliki layoutów w
Androidzie. Wszystkie znane mi do tej pory tego przykłady opierają się
na XML-u i dodatkowym programie generującym kod w trakcie kompilacji.
&lt;/p&gt;&lt;p&gt;Ostatnio pracuję nad podobną biblioteką dla Clojure. Są jednak dwie
główne różnice: 
&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;Tak jak dla programistów Javy naturalnym językiem do opisu danych jest XML tak dla programistów Clojure tym językiem jest Clojure.&lt;/li&gt;
&lt;li&gt;Moja biblioteka jest jedynie biblioteką, nie wymaga dodatkowych programów generujących (powiedzmy) kod Javy z XML-a.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Ad 1. Składnia Clojure to tylko struktury danych: listy, wektory i
mapy o &lt;em&gt;wybornej&lt;/em&gt; składni. Grzechem byłoby używać w takiej sytuacji
XML-a. Całe parsowanie robi za mnie Clojure więc mogę martwić się już
tylko znaczeniem tego co siedzi w środku. Zarówno drzewo GUI (analogia
do HTML) jak i style (CSS) definiowane są za pomocą kodu w Clojure.
&lt;/p&gt;&lt;p&gt;Ad 2. Dzięki magicznym technikom metaprogramowania (makrom) mogę
wchodzić w drogę kompilatorowi Clojure i generować kod tuż przed
kompilacją zamiast generować kod programem i dopiero potem wywoływać
kompilator. Dlatego całą funkcjonalność można spakować do pliku jar i
używać jak każdej innej biblioteki. Ułatwia to także programowanie
interaktywne z użyciem REPL.
&lt;/p&gt;&lt;h2&gt;Co, gdzie, jak?&lt;/h2&gt;&lt;p&gt;Teraz nieco więcej o samej bibliotece. Nazwałem ją &lt;strong&gt;GUI FTW!&lt;/strong&gt; a pobrać
ją można stąd: &lt;a href="http://github.com/santamon/GUIFTW"&gt;http://github.com/santamon/GUIFTW&lt;/a&gt;. Jest dostępna
także na &lt;a href="http://clojars.org/guiftw"&gt;Clojars&lt;/a&gt; więc wystarczy dodać
&lt;code&gt;[guiftw "0.1.0-SNAPSHOT"]&lt;/code&gt; do zależności projektu aby jej
użyć. Polecam poeksperymentować z przykładami w katalogu
&lt;a href="http://github.com/santamon/GUIFTW/blob/master/src/guiftw/examples"&gt;src/guiftw/examples&lt;/a&gt;, które są również mocno obkomentowane w formie tutoriala.
&lt;/p&gt;&lt;p&gt;GUI FTW! nie jest kolejnym toolkitem obok SWT i Swinga &amp;mdash; jest
deklaratywną nakładką na nie. Tzn. GUI FTW! można używać do tworzenia
interfejsów używając jednego albo drugiego pod spodem. Do tego zostało
napisane na tyle abstrakcyjnie, że można łatwo dopisać obsługę
kolejnego toolkitu. Ułatwi to przesiadkę programistom Javy, którzy
znają jedno albo drugie. Poza tym, pisanie kolejnego toolkitu nie jest
po prostu celem tego projektu.
&lt;/p&gt;&lt;h2&gt;Banalny przykład&lt;/h2&gt;&lt;p&gt;Strukturą GUI jest drzewo, którego węzeł składa się z nazwy
klasy, listy właściwości oraz z jego węzłów-dzieci.
&lt;/p&gt;&lt;pre&gt;(def window
 (swing
  [JFrame [:title "GUI FTW!"
           :visible true]
   [JButton [:text "To jest przycisk!"]]]))
&lt;/pre&gt;&lt;p&gt;Wewnątrz listy cech można używać dowolnych nazw, które mają swoje
settery w danej klasie. Np. &lt;code&gt;:title&lt;/code&gt; tłumaczone jest na wywołanie
metody &lt;code&gt;setTitle&lt;/code&gt;, &lt;code&gt;:default-close-operation&lt;/code&gt; na
&lt;code&gt;setDefaultCloseOperation&lt;/code&gt; itd.
&lt;/p&gt;&lt;p&gt;Aby zdefiniować style osobno musimy nadać elementom identyfikatory:
&lt;/p&gt;&lt;pre&gt;[JFrame [*id :okno-ftw]
 [JButton [*id :przycisk-omg]]]
&lt;/pre&gt;&lt;p&gt;a osobno w tzw. arkuszu stylów zdefiniować cechy obiektów:
&lt;/p&gt;&lt;pre&gt;(def sheet
 (stylesheet
  [:okno-ftw] [:title "GUI FTW!"
               :size ^unroll (300 200)
               :visible true]
  [:przycisk-omg] [:text "To jest przycisk!"]))
&lt;/pre&gt;&lt;p&gt;Składnia styli składa się z par list: najpierw lista identyfikatorów,
druga lista jest listą właściwości jak poprzednio. &lt;code&gt;^unroll&lt;/code&gt; jest
potrzebne dla setterów, które mają więcej niż jeden parametr. Lista
poprzedzona &lt;code&gt;^unroll&lt;/code&gt; zostanie rozwinięta na wszystkie jego parametry
zamiast wywołać setter z listą jako parametrem. Czyli otrzymamy
odpowiednik &lt;code&gt;setSize(300, 200)&lt;/code&gt; zamiast &lt;code&gt;setSize((300, 200))&lt;/code&gt;.
&lt;/p&gt;&lt;p&gt;Makro &lt;code&gt;swing&lt;/code&gt; zwraca funkcję, która utworzy chciane GUI, więc &lt;code&gt;window&lt;/code&gt;
będzie funkcją. Parametrami tej funkcji jest ew. obiekt nadrzędny
(jeśli nie tworzylibyśmy okna tylko jakiś podrzędny element, może być
nil) oraz dowolna ilość arkuszy styli. Utworzenie okna będzie więc
wyglądało tak:
&lt;/p&gt;&lt;pre&gt;(window nil sheet)
&lt;/pre&gt;&lt;p&gt;&lt;img src="gui-ftw-pierwsze-okno.png" alt="Pierwsze okno" /&gt;
&lt;/p&gt;&lt;p&gt;Arkuszy może być więcej, możemy także podać inny komplet. Możemy też
utworzyć wiele okien wywołując powtórnie tę funkcję. Zwrócony zostanie
element na korzeniu drzewa.
&lt;/p&gt;&lt;p&gt;Analogiczny przykład w SWT użyłby klas specyficznych dla SWT i przede
wszystkim makra &lt;code&gt;swt&lt;/code&gt; zamiast &lt;code&gt;swing&lt;/code&gt;.
&lt;/p&gt;&lt;h2&gt;Co dalej&lt;/h2&gt;&lt;p&gt;Zacząłem pisać dokumentację. Jest dostępna w kodzie bądź przez &lt;code&gt;doc&lt;/code&gt; w
REPL-u. Przydałaby się też dokumentacja on-line w stylu &lt;a href="http://clojure.github.com/clojure/"&gt;tej&lt;/a&gt;
dla samego Clojure.
&lt;/p&gt;&lt;p&gt;W tym momencie można stworzyć GUI, ostylować go i podpiąć zdarzenia (o
czym będzie następny wpis). Brakuje całej części "stanowej", w
szczególności wyciąganie z drzewa interesujących nas elementów. Mam
również pomysł, by podpinać wartości (np. tekst pola tekstowego)
dwustronnie pod clojure'owe atomy, refy, agentów itp. Pozwoliłoby to
na spięcie GUI i np. pamięci transakcyjnej.
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Idea i Iluzja łeb w web</title>
    <link href="http://longstandingbug.com/idea-iluzja.html" rel="alternate" />
    <id>http://longstandingbug.com/idea-iluzja.html</id>
    <updated>2010-10-16T00:00:00Z</updated>
    <published>2010-10-16T00:00:00Z</published>
    <content type="html">&lt;p&gt;Co najbardziej lubię w Makeblogu, to składnia plików wejściowych. Na dobrą 
sprawę mógłbym ich nie parsować wcale. Same w sobie mają odpowiedni wygląd.
Myślę, że gdybym pisał przeglądarkę tekstową zamieniałbym strony z HTML-a na coś
podobnego ;).
&lt;/p&gt;&lt;p&gt;To co mam na myśli, zpikselowane:
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="idea-iluzja.png"&gt;&lt;img src="idea-iluzja_m.png" alt="zrzut ekranu" /&gt;&lt;/a&gt; &lt;br /&gt;
&lt;em&gt;Z lewej strony źródło wpisu, z prawej efekt.&lt;/em&gt;
&lt;/p&gt;&lt;p&gt;Choć ciągle w fazie rozwojowej, Makeblog w tym momencie realizuje większość
funkcji, które założyłem. Następnym krokiem będzie dokumentacja.
Nie widzę innego wyjścia jak generowanie jej Makeblogiem we własnej osobie.
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Błąd młodego parsownika</title>
    <link href="http://longstandingbug.com/blad-mlodego-parsownika.html" rel="alternate" />
    <id>http://longstandingbug.com/blad-mlodego-parsownika.html</id>
    <updated>2010-09-03T00:00:00Z</updated>
    <published>2010-09-03T00:00:00Z</published>
    <content type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;Parsownik&lt;/strong&gt; &amp;mdash; osoba pisząca parsery.&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;(Termin zawdzięczam mojemu bratu.)&lt;/em&gt;
&lt;/p&gt;&lt;p&gt;Od pierwszego wpisu tutaj minęły 2 tygodnie. Najlepsze jest to, że
zacząłem pisać następny wpis już następnego dnia po wystartowaniu
bloga. Cały wpis powstał bez sprawdzania czy kompiluje się ładnie do
HTML-a. Po ukończeniu skompilował się, niestety źle. Bardzo
źle. Tagi przeplatały się w nieprawidłowy sposób, np. gwiazdka gdzieś
wcześniej w którymś paragrafie i gwiazdka gdzieś dalej w wypunktowaniu
powodowały otoczenie to tagiem &amp;lt;b&amp;gt;. Co dawało np. takie wyjście:
&lt;/p&gt;&lt;pre&gt;... &amp;lt;p&amp;gt; ... &amp;lt;b&amp;gt; ... &amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; ... &amp;lt;/b&amp;gt; ...
&lt;/pre&gt;&lt;p&gt;Mój parser działał ogólnie tak, że miał listę par: wyrażenie regularne
+ funkcja, która wywoływana była na tekście do którego zostało
dopasowane to wyrażenie. Aby zapobiec złemu przeplataniu się
tagów wyrażenia ozdobników (takich jak pogrubienie, pochylenie,
podkreślenie; do tego używam pojedynczych znaków, np:
&lt;code&gt;/asdf/&lt;/code&gt; → &lt;code&gt;&amp;lt;em&amp;gt;asdf&amp;lt;/em&amp;gt;&lt;/code&gt;)
stały się bardzo skomplikowane. Mam na myśli coś takiego
(&lt;code&gt;@&lt;/code&gt; to odpowiednik dla znacznika &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;):
&lt;/p&gt;&lt;pre&gt;r"(?&amp;lt;!&amp;lt;|\w|[@])\@(?=\S)([^@]+)(?&amp;lt;=\S)\@(?=\W)"
&lt;/pre&gt;&lt;p&gt;Nie jestem specjalistą od wyrażeń regularnych ale użycie ich wydawało
mi się bardzo obiecujące. Szczególnie łatwo było na początku ;).
&lt;/p&gt;&lt;p&gt;Przedstawione podejście miało poważne wady:
&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;za każdym razem przetwarzany był cały tekst,&lt;/li&gt;
&lt;li&gt;wyrażenia widziały go jako sam tekst a nie jako strukturę,&lt;/li&gt;
&lt;li&gt;w praktyce dopuszczalne było przeplatanie się znaczników HTML j/w.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Ogólnie całość sprawiała wrażenie jakby trzymała się na rzęsach :P.
Ciągłe dopasowywanie regexpów mogło się szybko skończyć kodem
spaghetti... Jednym słowem...
&lt;/p&gt;&lt;h2&gt;Porażka :D.&lt;/h2&gt;&lt;p&gt;Mogłem spodziewać się tego po przeczytaniu &lt;a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454"&gt;tego wątku na Stack Overflow&lt;/a&gt;.
Dotyczył on parsowania HTML-a więc najpierw pomyślałem, że moja 
wymarzona składnia nie jest aż tak trudna do przetworzenia.
&lt;/p&gt;&lt;p&gt;Wróciłem do Stack Overflow jak mój parser zaczął nawalać...
&lt;/p&gt;&lt;h2&gt;Pyparsing&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;Have you tried using an XML parser instead?
&amp;mdash; &lt;a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454"&gt;Will&lt;/a&gt;
&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Wow. To mi dało myślenia. Oczywiście nie chodziło o użycie parsera XML-a
ale śladem "gotowych, dobrze sprawdzonych rozwiązań" trafiłem na
&lt;a href="http://pyparsing.wikispaces.com/"&gt;pyparsing&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Pyparsing jest (dla mnie, laika z tego tematu :P ) parserem dowolnie
zdefiniowanej gramatyki. Od np. &lt;a href="http://www.antlr.org/"&gt;ANTLR-a&lt;/a&gt; różni się
tym, że gramatykę definiuje się za pomocą wyrażeń w Pythonie (używając
zwykłych operatorów takich jak &lt;code&gt;+&lt;/code&gt; czy &lt;code&gt;|&lt;/code&gt;)
zamiast tradycyjnego &lt;a href="http://pl.wikipedia.org/wiki/Notacja_EBNF"&gt;EBNF&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Idealnie dla mnie. Wystarczyło zrozumieć filozofię działania, przeczytać
&lt;a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html"&gt;krótką i przystępną instrukcję&lt;/a&gt;
oraz czasem zajrzeć do &lt;a href="http://packages.python.org/pyparsing/"&gt;dokumentacji API&lt;/a&gt;.
&lt;/p&gt;&lt;h3&gt;Prosty przykład&lt;/h3&gt;&lt;p&gt;Skoro jesteśmy przy moich &lt;strong&gt;pogrubieniach&lt;/strong&gt; za pomocą gwiazdki i
&lt;em&gt;pochyleniach&lt;/em&gt; za pomocą ukośnika, proponuję prosty, rekurencyjny przykład.
&lt;/p&gt;&lt;p&gt;Najpierw wersja nierekurencyjna:
&lt;/p&gt;&lt;pre&gt;# -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( # tłumaczy się samo przez się
                         Word( # słowo (przynajmniej 1 znak) złożone z:
                               alphanums)) # litery i cyfry

bold = "*" + undecorated + "*"   # prawda,
italic = "/" + undecorated + "/" # że proste? :)

# metoda parseString() służy do... parsowania napisów
pprint(bold.parseString("*asdf*").asList())
pprint(italic.parseString("/qwer/").asList())
&lt;/pre&gt;&lt;p&gt;Wynikiem tego będzie:
&lt;/p&gt;&lt;pre&gt;['*', 'asdf', '*']
['/', 'qwer', '/']
&lt;/pre&gt;&lt;p&gt;Jak widać, pyparsing dzieli łańcuch na kawałki określone w gramatyce
(tokeny). Domyślnie omija też ew. białe znaki pomiędzy nimi.
&lt;/p&gt;&lt;p&gt;Rekurencyjny przykład będzie nieco dłuższy. Ponieważ Python nie pozwala
na używanie niezdefiniowanych symboli pyparsing załatwia to
klasą &lt;code&gt;Forward&lt;/code&gt;, która umożliwia najpierw zadeklarowanie elementu
a później podanie jego definicji za pomocą operatora &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;.
&lt;/p&gt;&lt;pre&gt;# -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( Word(alphanums))

bold = Forward()
italic = Forward()

expression = OneOrMore( undecorated | bold | italic )

# Domyślnie wszystkie elementy odnalezione przez pyparsing
# zwracane są jako jednowymiarowa lista, Group stworzy
# listę zagnieżdżoną dla tego dopasowania
bold &amp;lt;&amp;lt; Group("*" + expression + "*")
italic &amp;lt;&amp;lt; Group("/" + expression + "/")

pprint(expression.parseString("""
czysty tekst
/krzywo/ *grubo*
/*krzywo grubo*/ */grubo krzywo/*
*grubo /krzywo i jeszcze raz *grubo*/*
""").asList())
&lt;/pre&gt;&lt;p&gt;Tym razem wyjście wygląda tak:
&lt;/p&gt;&lt;pre&gt;['czysty', 'tekst',        # czysty tekst
 ['/', 'krzywo', '/'],     # /krzywo/
 ['*', 'grubo', '*'],      # *grubo*
 ['/', ['*', 'krzywo', 'grubo', '*'], '/'], # /*krzywo grubo*/
 ['*', ['/', 'grubo', 'krzywo', '/'], '*'], # */grubo krzywo/*
 ['*', 'grubo',
  ['/', 'krzywo', 'i', 'jeszcze', 'raz',
   ['*', 'grubo', '*'],
   '/'],
  '*']]
&lt;/pre&gt;&lt;p&gt;Ostatni kawałek jest szczególnie ciekawy. Zostawiam go
do samodzielnego przeanalizowania :P. Dla mnie to była eureka,
która pozwoliła mi dalej popchnąć projekt :)
&lt;/p&gt;&lt;p&gt;Oba przykłady umieszczone są w &lt;a href="input/blad-mlodego-parsownika.py"&gt;jednym pliku&lt;/a&gt;.
Plik ten posiada jeszcze jeden cukierek dla osób wnikliwych ;).
Przedstawiony przykład jest uproszczeniem analogicznego kodu
z mojego &lt;a href="http://github.com/santamon/makeblog/blob/master/txt-to-html/txt-to-html.py"&gt;parsera&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Takie drzewko jak w ostatnim listingu możemy już dowolnie przetworzyć
manipulując listami, albo użyć metody &lt;code&gt;setParseAction(fn)&lt;/code&gt; na każdym
zdefiniowanym elemencie gramatyki, gdzie &lt;code&gt;fn&lt;/code&gt; to funkcja.
Jeśli &lt;code&gt;fn&lt;/code&gt; zwróci jakąś wartość to element w drzewie zostanie
zastąpiony tą wartością.
&lt;/p&gt;&lt;h2&gt;Podsumowanie&lt;/h2&gt;&lt;p&gt;Nowy parser pozbawiony jest wad poprzedniego, przede wszystkim:
&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;działa,&lt;/li&gt;
&lt;li&gt;jest bardziej przewidywalny,&lt;/li&gt;
&lt;li&gt;kod jest bardziej przejrzysty,&lt;/li&gt;
&lt;li&gt;jest łatwiej rozszerzalny.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Polecam przyjrzeć się &lt;a href="http://pyparsing.wikispaces.com/"&gt;pyparsing&lt;/a&gt; jeśli
mamy potrzebę/chęć przetworzenia jakiegoś tekstu i piszemy
w Pythonie. Jeszcze raz podaję adres do &lt;a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html"&gt;samouczka&lt;/a&gt;
oraz do &lt;a href="http://packages.python.org/pyparsing/"&gt;dokumentacji API&lt;/a&gt;.
Pyparsing ma bardzo fajną licencję (&lt;a href="http://www.opensource.org/licenses/mit-license.php"&gt;MIT&lt;/a&gt;, "róbta co chceta ale pochwalcie się od kogo ściągaliście" :P ) i jest dość popularne, co znaczy, że powinna być dostępna w
Twojej Ulubionej Dystrybucji ;).
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Intro</title>
    <link href="http://longstandingbug.com/intro.html" rel="alternate" />
    <id>http://longstandingbug.com/intro.html</id>
    <updated>2010-08-16T00:00:00Z</updated>
    <published>2010-08-16T00:00:00Z</published>
    <content type="html">&lt;p&gt;Witam serdecznie. O blogu, który by się tak nazywał, działał i wyglądał myślałem
od jakiegoś czasu. Będę pisał o własnych zainteresowaniach,
skupiając się zapewne w głównej mierze na języku &lt;a href="http://clojure.org"&gt;Clojure&lt;/a&gt;.
Mam dwa pomysły na pracę mgr, których, dopóki nie dorosną, nie zdradzę.
&lt;/p&gt;&lt;p&gt;Wygląd strony jest minimalistyczny; mam nadzieję, że jeśli nie przypadnie 
komuś do gustu to przynajmniej nie będzie przeszkadzał w dostępie do treści.
&lt;/p&gt;&lt;h2&gt;Makeblog&lt;/h2&gt;&lt;p&gt;Na potrzeby bloga napisałem kilka skryptów do generowania stron off-line.
Kilka zalet takiego rozwiązania (porównując np. z Wordpressem):
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;strony ładują się szybciej, nie ma odwołań do bazy danych,&lt;/li&gt;
&lt;li&gt;mogę użyć dowolnego edytora do edycji stron/wpisów,&lt;/li&gt;
&lt;li&gt;całą treść trzymam u siebie na dysku, zmiana hostingu jest dzięki temu uproszczona.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;W tym momencie strona hostowana jest na &lt;a href="http://github.com/santamon/santamon.github.com"&gt;GitHubie&lt;/a&gt;,
co mi bardzo odpowiada: synchronizacja treści przez gita, cud-miód &lt;code&gt;:)&lt;/code&gt;.
&lt;/p&gt;&lt;p&gt;Makeblog używa składni podobnej do &lt;a href="http://orgmode.org"&gt;&lt;code&gt;org-mode&lt;/code&gt;'a&lt;/a&gt;.
Dzięki temu mogę pisać wpisy w czystym tekście, polecam zobaczyć
&lt;a href="http://github.com/santamon/santamon.github.com/blob/master/input/intro.txt"&gt;plik źródłowy tego wpisu&lt;/a&gt; 
oraz plik &lt;a href="http://github.com/santamon/makeblog/blob/master/input/Syntax.txt"&gt;Syntax&lt;/a&gt;, którego używałem do testowania parsera.
&lt;a href="http://github.com/santamon/santamon.github.com/blob/master/templates/article.html"&gt;Schematy stron&lt;/a&gt; używają bardzo prostej składni (podmiany z &lt;code&gt;$&lt;/code&gt;).
&lt;/p&gt;&lt;h3&gt;Skąd taka nazwa?&lt;/h3&gt;&lt;p&gt;Proste: Makeblog używa programu &lt;strong&gt;make&lt;/strong&gt; do śledzenia, które pliki mają być
zaktualizowane. Skrypty do parsowania tekstu i indeksowania są napisane
w Pythonie. Dlaczego nie w Clojure? Może więcej o Makeblogu w następnym
wpisie.
&lt;/p&gt;&lt;p&gt;Projekt jest hostowany na &lt;a href="http://launchpad.net/makeblog"&gt;&lt;del&gt;Launchpadzie&lt;/del&gt;&lt;/a&gt; GitHubie: &lt;a href="http://github.com/santamon/makeblog"&gt;http://github.com/santamon/makeblog&lt;/a&gt;.
&lt;del&gt;Ludzie przywykli do githuba wolą od razu zobaczyć kod: &lt;a href="http://bazaar.launchpad.net/~santamon/makeblog/trunk/files"&gt;http://bazaar.launchpad.net/~santamon/makeblog/trunk/files&lt;/a&gt;&lt;/del&gt;.
&lt;/p&gt;&lt;h2&gt;Braki i niedoróbki&lt;/h2&gt;&lt;p&gt;Póki co zauważyłem problemy z renderowaniem czcionek pod Windowsem (gdy używa się
ClearType, pod Safari z renderowaniem "makowym" wygląda b. dobrze).
Dlatego na Viście i 7 zostaną użyte kroje systemowe (nowe kroje wprowadzone z Vistą,
nie ma ich w innych OS-ach, więc na Linuksie zostaną użyte te zagnieżdżone). Na XP jeszcze
nie wiem co zrobić. Zobaczymy po testach (nie mam komputera z XP pod ręką ostatnio).
&lt;/p&gt;&lt;p&gt;Brakuje kilku istotnych łebdwazerowych funkcji, czyli tagów i RSS-a lub Atoma.
Jest w moim TODO &lt;code&gt;;)&lt;/code&gt;.
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Efekty uboczne programowania</title>
    <link href="http://longstandingbug.com/efekty-uboczne-programowania.html" rel="alternate" />
    <id>http://longstandingbug.com/efekty-uboczne-programowania.html</id>
    <updated>2010-01-07T00:00:00Z</updated>
    <published>2010-01-07T00:00:00Z</published>
    <content type="html">&lt;p class="makeblog_box makeblog_box_right"&gt;Wpis archiwalny z &lt;a href="http://gaco.wordpress.com"&gt;mojej starej strony&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Pliki png w pełnej rozdzielczości mają po 2-4,5 MB.
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="abstract1.png"&gt;&lt;img src="abstract1_m.png" alt="Abstrakcja 1" /&gt;&lt;/a&gt;
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="abstract2.png"&gt;&lt;img src="abstract2_m.png" alt="Abstrakcja 2" /&gt;&lt;/a&gt;
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="scan-lines.png"&gt;&lt;img src="scan-lines_m.png" alt="Scan lines" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;em&gt;Efekt niedokończonej optymalizacji odświeżania obrazu&lt;/em&gt;
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>One Makefile To Rule Them All</title>
    <link href="http://longstandingbug.com/one-makefile-to-rule-them-all.html" rel="alternate" />
    <id>http://longstandingbug.com/one-makefile-to-rule-them-all.html</id>
    <updated>2009-06-07T00:00:00Z</updated>
    <published>2009-06-07T00:00:00Z</published>
    <content type="html">&lt;blockquote&gt;&lt;p&gt;One Makefile to rule them all, One Makefile to find them,&lt;br /&gt;
One Makefile to bring them all and in the batch compile them&lt;br /&gt;
In the Land of Unix where the Shells lie.
&lt;/p&gt;&lt;/blockquote&gt;&lt;p class="makeblog_box makeblog_box_right"&gt;Wpis archiwalny z &lt;a href="http://gaco.wordpress.com"&gt;mojej starej strony&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Kiedyś szukałem sposobu, by dodając nowe pliki *.cpp do projektu
(każdy z nich był osobnym programem) nie trzeba było modyfikować
Makefile'a i dałem sobie spokój w pewnym momencie.  Szukałem niezbyt
gorliwie jak się okazuje, bo podpowiedź była
&lt;a href="http://www.gnu.org/software/make/manual/html_node/Wildcard-Function.html"&gt;w manualu do GNU Make'a&lt;/a&gt;.
Ten Makefile skompiluje wszystkie pliki *.cpp jako osobne programy
do podkatalogu bin.
&lt;/p&gt;&lt;pre&gt;cele := $(patsubst %.cpp,bin/%,$(wildcard *.cpp))

komp=g++ -Wall -O2

asdf: $(cele)

$(cele) : bin/% : %.cpp
        $(komp) $&amp;lt; -o $@

clean:
        rm $(cele)
&lt;/pre&gt;&lt;p&gt;Żeby pakowało binarki bezpośrednio do katalogu ze źródłami trzeba usunąć 2x &lt;code&gt;bin/&lt;/code&gt;.
&lt;/p&gt;</content>
  </entry>

</feed>
