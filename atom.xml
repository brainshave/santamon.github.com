<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long-standing Bug</title> 
  <link href="http://longstandingbug.com" rel="self" />
  <updated>2010-11-27T10:25:40Z</updated>
  <author> 
    <name>Szymon Witamborski</name>
  </author>
  <id>http://longstandingbug.com/./atom.xml</id>
  
  <entry>
    <title>Idea i Iluzja łeb w web</title>
    <link href="http://longstandingbug.com/idea-iluzja.html" rel="alternate" />
    <id>http://longstandingbug.com/idea-iluzja.html</id>
    <updated>2010-10-16T00:00:00Z</updated>
    <published>2010-10-16T00:00:00Z</published>
    <content type="html">&lt;p&gt;Co najbardziej lubię w Makeblogu, to składnia plików wejściowych. Na dobrą 
sprawę mógłbym ich nie parsować wcale. Same w sobie mają odpowiedni wygląd.
Myślę, że gdybym pisał przeglądarkę tekstową zamieniałbym strony z HTML-a na coś
podobnego ;).
&lt;/p&gt;&lt;p&gt;To co mam na myśli, zpikselowane:
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="idea-iluzja.png"&gt;&lt;img src="idea-iluzja_m.png" alt="zrzut ekranu" /&gt;&lt;/a&gt; &lt;br /&gt;
&lt;em&gt;Z lewej strony źródło wpisu, z prawej efekt.&lt;/em&gt;
&lt;/p&gt;&lt;p&gt;Choć ciągle w fazie rozwojowej, Makeblog w tym momencie realizuje większość
funkcji, które założyłem. Następnym krokiem będzie dokumentacja.
Nie widzę innego wyjścia jak generowanie jej Makeblogiem we własnej osobie.
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Błąd młodego parsownika</title>
    <link href="http://longstandingbug.com/blad-mlodego-parsownika.html" rel="alternate" />
    <id>http://longstandingbug.com/blad-mlodego-parsownika.html</id>
    <updated>2010-09-03T00:00:00Z</updated>
    <published>2010-09-03T00:00:00Z</published>
    <content type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;Parsownik&lt;/strong&gt; &amp;mdash; osoba pisząca parsery.&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;(Termin zawdzięczam mojemu bratu.)&lt;/em&gt;
&lt;/p&gt;&lt;p&gt;Od pierwszego wpisu tutaj minęły 2 tygodnie. Najlepsze jest to, że
zacząłem pisać następny wpis już następnego dnia po wystartowaniu
bloga. Cały wpis powstał bez sprawdzania czy kompiluje się ładnie do
HTML-a. Po ukończeniu skompilował się, niestety źle. Bardzo
źle. Tagi przeplatały się w nieprawidłowy sposób, np. gwiazdka gdzieś
wcześniej w którymś paragrafie i gwiazdka gdzieś dalej w wypunktowaniu
powodowały otoczenie to tagiem &amp;lt;b&amp;gt;. Co dawało np. takie wyjście:
&lt;/p&gt;&lt;pre&gt;... &amp;lt;p&amp;gt; ... &amp;lt;b&amp;gt; ... &amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; ... &amp;lt;/b&amp;gt; ...
&lt;/pre&gt;&lt;p&gt;Mój parser działał ogólnie tak, że miał listę par: wyrażenie regularne
+ funkcja, która wywoływana była na tekście do którego zostało
dopasowane to wyrażenie. Aby zapobiec złemu przeplataniu się
tagów wyrażenia ozdobników (takich jak pogrubienie, pochylenie,
podkreślenie; do tego używam pojedynczych znaków, np:
&lt;code&gt;/asdf/&lt;/code&gt; → &lt;code&gt;&amp;lt;em&amp;gt;asdf&amp;lt;/em&amp;gt;&lt;/code&gt;)
stały się bardzo skomplikowane. Mam na myśli coś takiego
(&lt;code&gt;@&lt;/code&gt; to odpowiednik dla znacznika &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;):
&lt;/p&gt;&lt;pre&gt;r"(?&amp;lt;!&amp;lt;|\w|[@])\@(?=\S)([^@]+)(?&amp;lt;=\S)\@(?=\W)"
&lt;/pre&gt;&lt;p&gt;Nie jestem specjalistą od wyrażeń regularnych ale użycie ich wydawało
mi się bardzo obiecujące. Szczególnie łatwo było na początku ;).
&lt;/p&gt;&lt;p&gt;Przedstawione podejście miało poważne wady:
&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;za każdym razem przetwarzany był cały tekst,&lt;/li&gt;
&lt;li&gt;wyrażenia widziały go jako sam tekst a nie jako strukturę,&lt;/li&gt;
&lt;li&gt;w praktyce dopuszczalne było przeplatanie się znaczników HTML j/w.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Ogólnie całość sprawiała wrażenie jakby trzymała się na rzęsach :P.
Ciągłe dopasowywanie regexpów mogło się szybko skończyć kodem
spaghetti... Jednym słowem...
&lt;/p&gt;&lt;h2&gt;Porażka :D.&lt;/h2&gt;&lt;p&gt;Mogłem spodziewać się tego po przeczytaniu &lt;a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454"&gt;tego wątku na Stack Overflow&lt;/a&gt;.
Dotyczył on parsowania HTML-a więc najpierw pomyślałem, że moja 
wymarzona składnia nie jest aż tak trudna do przetworzenia.
&lt;/p&gt;&lt;p&gt;Wróciłem do Stack Overflow jak mój parser zaczął nawalać...
&lt;/p&gt;&lt;h2&gt;Pyparsing&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;Have you tried using an XML parser instead?
&amp;mdash; &lt;a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454"&gt;Will&lt;/a&gt;
&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Wow. To mi dało myślenia. Oczywiście nie chodziło o użycie parsera XML-a
ale śladem "gotowych, dobrze sprawdzonych rozwiązań" trafiłem na
&lt;a href="http://pyparsing.wikispaces.com/"&gt;pyparsing&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Pyparsing jest (dla mnie, laika z tego tematu :P ) parserem dowolnie
zdefiniowanej gramatyki. Od np. &lt;a href="http://www.antlr.org/"&gt;ANTLR-a&lt;/a&gt; różni się
tym, że gramatykę definiuje się za pomocą wyrażeń w Pythonie (używając
zwykłych operatorów takich jak &lt;code&gt;+&lt;/code&gt; czy &lt;code&gt;|&lt;/code&gt;)
zamiast tradycyjnego &lt;a href="http://pl.wikipedia.org/wiki/Notacja_EBNF"&gt;EBNF&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Idealnie dla mnie. Wystarczyło zrozumieć filozofię działania, przeczytać
&lt;a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html"&gt;krótką i przystępną instrukcję&lt;/a&gt;
oraz czasem zajrzeć do &lt;a href="http://packages.python.org/pyparsing/"&gt;dokumentacji API&lt;/a&gt;.
&lt;/p&gt;&lt;h3&gt;Prosty przykład&lt;/h3&gt;&lt;p&gt;Skoro jesteśmy przy moich &lt;strong&gt;pogrubieniach&lt;/strong&gt; za pomocą gwiazdki i
&lt;em&gt;pochyleniach&lt;/em&gt; za pomocą ukośnika, proponuję prosty, rekurencyjny przykład.
&lt;/p&gt;&lt;p&gt;Najpierw wersja nierekurencyjna:
&lt;/p&gt;&lt;pre&gt;# -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( # tłumaczy się samo przez się
                         Word( # słowo (przynajmniej 1 znak) złożone z:
                               alphanums)) # litery i cyfry

bold = "*" + undecorated + "*"   # prawda,
italic = "/" + undecorated + "/" # że proste? :)

# metoda parseString() służy do... parsowania napisów
pprint(bold.parseString("*asdf*").asList())
pprint(italic.parseString("/qwer/").asList())
&lt;/pre&gt;&lt;p&gt;Wynikiem tego będzie:
&lt;/p&gt;&lt;pre&gt;['*', 'asdf', '*']
['/', 'qwer', '/']
&lt;/pre&gt;&lt;p&gt;Jak widać, pyparsing dzieli łańcuch na kawałki określone w gramatyce
(tokeny). Domyślnie omija też ew. białe znaki pomiędzy nimi.
&lt;/p&gt;&lt;p&gt;Rekurencyjny przykład będzie nieco dłuższy. Ponieważ Python nie pozwala
na używanie niezdefiniowanych symboli pyparsing załatwia to
klasą &lt;code&gt;Forward&lt;/code&gt;, która umożliwia najpierw zadeklarowanie elementu
a później podanie jego definicji za pomocą operatora &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;.
&lt;/p&gt;&lt;pre&gt;# -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( Word(alphanums))

bold = Forward()
italic = Forward()

expression = OneOrMore( undecorated | bold | italic )

# Domyślnie wszystkie elementy odnalezione przez pyparsing
# zwracane są jako jednowymiarowa lista, Group stworzy
# listę zagnieżdżoną dla tego dopasowania
bold &amp;lt;&amp;lt; Group("*" + expression + "*")
italic &amp;lt;&amp;lt; Group("/" + expression + "/")

pprint(expression.parseString("""
czysty tekst
/krzywo/ *grubo*
/*krzywo grubo*/ */grubo krzywo/*
*grubo /krzywo i jeszcze raz *grubo*/*
""").asList())
&lt;/pre&gt;&lt;p&gt;Tym razem wyjście wygląda tak:
&lt;/p&gt;&lt;pre&gt;['czysty', 'tekst',        # czysty tekst
 ['/', 'krzywo', '/'],     # /krzywo/
 ['*', 'grubo', '*'],      # *grubo*
 ['/', ['*', 'krzywo', 'grubo', '*'], '/'], # /*krzywo grubo*/
 ['*', ['/', 'grubo', 'krzywo', '/'], '*'], # */grubo krzywo/*
 ['*', 'grubo',
  ['/', 'krzywo', 'i', 'jeszcze', 'raz',
   ['*', 'grubo', '*'],
   '/'],
  '*']]
&lt;/pre&gt;&lt;p&gt;Ostatni kawałek jest szczególnie ciekawy. Zostawiam go
do samodzielnego przeanalizowania :P. Dla mnie to była eureka,
która pozwoliła mi dalej popchnąć projekt :)
&lt;/p&gt;&lt;p&gt;Oba przykłady umieszczone są w &lt;a href="input/blad-mlodego-parsownika.py"&gt;jednym pliku&lt;/a&gt;.
Plik ten posiada jeszcze jeden cukierek dla osób wnikliwych ;).
Przedstawiony przykład jest uproszczeniem analogicznego kodu
z mojego &lt;a href="http://github.com/santamon/makeblog/blob/master/txt-to-html/txt-to-html.py"&gt;parsera&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Takie drzewko jak w ostatnim listingu możemy już dowolnie przetworzyć
manipulując listami, albo użyć metody &lt;code&gt;setParseAction(fn)&lt;/code&gt; na każdym
zdefiniowanym elemencie gramatyki, gdzie &lt;code&gt;fn&lt;/code&gt; to funkcja.
Jeśli &lt;code&gt;fn&lt;/code&gt; zwróci jakąś wartość to element w drzewie zostanie
zastąpiony tą wartością.
&lt;/p&gt;&lt;h2&gt;Podsumowanie&lt;/h2&gt;&lt;p&gt;Nowy parser pozbawiony jest wad poprzedniego, przede wszystkim:
&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;działa,&lt;/li&gt;
&lt;li&gt;jest bardziej przewidywalny,&lt;/li&gt;
&lt;li&gt;kod jest bardziej przejrzysty,&lt;/li&gt;
&lt;li&gt;jest łatwiej rozszerzalny.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Polecam przyjrzeć się &lt;a href="http://pyparsing.wikispaces.com/"&gt;pyparsing&lt;/a&gt; jeśli
mamy potrzebę/chęć przetworzenia jakiegoś tekstu i piszemy
w Pythonie. Jeszcze raz podaję adres do &lt;a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html"&gt;samouczka&lt;/a&gt;
oraz do &lt;a href="http://packages.python.org/pyparsing/"&gt;dokumentacji API&lt;/a&gt;.
Pyparsing ma bardzo fajną licencję (&lt;a href="http://www.opensource.org/licenses/mit-license.php"&gt;MIT&lt;/a&gt;, "róbta co chceta ale pochwalcie się od kogo ściągaliście" :P ) i jest dość popularne, co znaczy, że powinna być dostępna w
Twojej Ulubionej Dystrybucji ;).
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Intro</title>
    <link href="http://longstandingbug.com/intro.html" rel="alternate" />
    <id>http://longstandingbug.com/intro.html</id>
    <updated>2010-08-16T00:00:00Z</updated>
    <published>2010-08-16T00:00:00Z</published>
    <content type="html">&lt;p&gt;Witam serdecznie. O blogu, który by się tak nazywał, działał i wyglądał myślałem
od jakiegoś czasu. Będę pisał o własnych zainteresowaniach,
skupiając się zapewne w głównej mierze na języku &lt;a href="http://clojure.org"&gt;Clojure&lt;/a&gt;.
Mam dwa pomysły na pracę mgr, których, dopóki nie dorosną, nie zdradzę.
&lt;/p&gt;&lt;p&gt;Wygląd strony jest minimalistyczny; mam nadzieję, że jeśli nie przypadnie 
komuś do gustu to przynajmniej nie będzie przeszkadzał w dostępie do treści.
&lt;/p&gt;&lt;h2&gt;Makeblog&lt;/h2&gt;&lt;p&gt;Na potrzeby bloga napisałem kilka skryptów do generowania stron off-line.
Kilka zalet takiego rozwiązania (porównując np. z Wordpressem):
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;strony ładują się szybciej, nie ma odwołań do bazy danych,&lt;/li&gt;
&lt;li&gt;mogę użyć dowolnego edytora do edycji stron/wpisów,&lt;/li&gt;
&lt;li&gt;całą treść trzymam u siebie na dysku, zmiana hostingu jest dzięki temu uproszczona.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;W tym momencie strona hostowana jest na &lt;a href="http://github.com/santamon/santamon.github.com"&gt;GitHubie&lt;/a&gt;,
co mi bardzo odpowiada: synchronizacja treści przez gita, cud-miód &lt;code&gt;:)&lt;/code&gt;.
&lt;/p&gt;&lt;p&gt;Makeblog używa składni podobnej do &lt;a href="http://orgmode.org"&gt;&lt;code&gt;org-mode&lt;/code&gt;'a&lt;/a&gt;.
Dzięki temu mogę pisać wpisy w czystym tekście, polecam zobaczyć
&lt;a href="http://github.com/santamon/santamon.github.com/blob/master/input/intro.txt"&gt;plik źródłowy tego wpisu&lt;/a&gt; 
oraz plik &lt;a href="http://github.com/santamon/makeblog/blob/master/input/Syntax.txt"&gt;Syntax&lt;/a&gt;, którego używałem do testowania parsera.
&lt;a href="http://github.com/santamon/santamon.github.com/blob/master/templates/article.html"&gt;Schematy stron&lt;/a&gt; używają bardzo prostej składni (podmiany z &lt;code&gt;$&lt;/code&gt;).
&lt;/p&gt;&lt;h3&gt;Skąd taka nazwa?&lt;/h3&gt;&lt;p&gt;Proste: Makeblog używa programu &lt;strong&gt;make&lt;/strong&gt; do śledzenia, które pliki mają być
zaktualizowane. Skrypty do parsowania tekstu i indeksowania są napisane
w Pythonie. Dlaczego nie w Clojure? Może więcej o Makeblogu w następnym
wpisie.
&lt;/p&gt;&lt;p&gt;Projekt jest hostowany na &lt;a href="http://launchpad.net/makeblog"&gt;&lt;del&gt;Launchpadzie&lt;/del&gt;&lt;/a&gt; GitHubie: &lt;a href="http://github.com/santamon/makeblog"&gt;http://github.com/santamon/makeblog&lt;/a&gt;.
&lt;del&gt;Ludzie przywykli do githuba wolą od razu zobaczyć kod: &lt;a href="http://bazaar.launchpad.net/~santamon/makeblog/trunk/files"&gt;http://bazaar.launchpad.net/~santamon/makeblog/trunk/files&lt;/a&gt;&lt;/del&gt;.
&lt;/p&gt;&lt;h2&gt;Braki i niedoróbki&lt;/h2&gt;&lt;p&gt;Póki co zauważyłem problemy z renderowaniem czcionek pod Windowsem (gdy używa się
ClearType, pod Safari z renderowaniem "makowym" wygląda b. dobrze).
Dlatego na Viście i 7 zostaną użyte kroje systemowe (nowe kroje wprowadzone z Vistą,
nie ma ich w innych OS-ach, więc na Linuksie zostaną użyte te zagnieżdżone). Na XP jeszcze
nie wiem co zrobić. Zobaczymy po testach (nie mam komputera z XP pod ręką ostatnio).
&lt;/p&gt;&lt;p&gt;Brakuje kilku istotnych łebdwazerowych funkcji, czyli tagów i RSS-a lub Atoma.
Jest w moim TODO &lt;code&gt;;)&lt;/code&gt;.
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>Efekty uboczne programowania</title>
    <link href="http://longstandingbug.com/efekty-uboczne-programowania.html" rel="alternate" />
    <id>http://longstandingbug.com/efekty-uboczne-programowania.html</id>
    <updated>2010-01-07T00:00:00Z</updated>
    <published>2010-01-07T00:00:00Z</published>
    <content type="html">&lt;p class="makeblog_box makeblog_box_right"&gt;Wpis archiwalny z &lt;a href="http://gaco.wordpress.com"&gt;mojej starej strony&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Pliki png w pełnej rozdzielczości mają po 2-4,5 MB.
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="abstract1.png"&gt;&lt;img src="abstract1_m.png" alt="Abstrakcja 1" /&gt;&lt;/a&gt;
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="abstract2.png"&gt;&lt;img src="abstract2_m.png" alt="Abstrakcja 2" /&gt;&lt;/a&gt;
&lt;/p&gt;&lt;p class="makeblog_center"&gt;&lt;a href="scan-lines.png"&gt;&lt;img src="scan-lines_m.png" alt="Scan lines" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;em&gt;Efekt niedokończonej optymalizacji odświeżania obrazu&lt;/em&gt;
&lt;/p&gt;</content>
  </entry>

  <entry>
    <title>One Makefile To Rule Them All</title>
    <link href="http://longstandingbug.com/one-makefile-to-rule-them-all.html" rel="alternate" />
    <id>http://longstandingbug.com/one-makefile-to-rule-them-all.html</id>
    <updated>2009-06-07T00:00:00Z</updated>
    <published>2009-06-07T00:00:00Z</published>
    <content type="html">&lt;blockquote&gt;&lt;p&gt;One Makefile to rule them all, One Makefile to find them,&lt;br /&gt;
One Makefile to bring them all and in the batch compile them&lt;br /&gt;
In the Land of Unix where the Shells lie.
&lt;/p&gt;&lt;/blockquote&gt;&lt;p class="makeblog_box makeblog_box_right"&gt;Wpis archiwalny z &lt;a href="http://gaco.wordpress.com"&gt;mojej starej strony&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;Kiedyś szukałem sposobu, by dodając nowe pliki *.cpp do projektu
(każdy z nich był osobnym programem) nie trzeba było modyfikować
Makefile'a i dałem sobie spokój w pewnym momencie.  Szukałem niezbyt
gorliwie jak się okazuje, bo podpowiedź była
&lt;a href="http://www.gnu.org/software/make/manual/html_node/Wildcard-Function.html"&gt;w manualu do GNU Make'a&lt;/a&gt;.
Ten Makefile skompiluje wszystkie pliki *.cpp jako osobne programy
do podkatalogu bin.
&lt;/p&gt;&lt;pre&gt;cele := $(patsubst %.cpp,bin/%,$(wildcard *.cpp))

komp=g++ -Wall -O2

asdf: $(cele)

$(cele) : bin/% : %.cpp
        $(komp) $&amp;lt; -o $@

clean:
        rm $(cele)
&lt;/pre&gt;&lt;p&gt;Żeby pakowało binarki bezpośrednio do katalogu ze źródłami trzeba usunąć 2x &lt;code&gt;bin/&lt;/code&gt;.
&lt;/p&gt;</content>
  </entry>

</feed>
