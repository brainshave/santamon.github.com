<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="media/bug-inv.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Long Standing Bug" href="atom.xml" />
    <link rel="stylesheet" href="media/fonts.css" />
    <link rel="stylesheet" href="media/makeblog.css" />
    <link rel="stylesheet" href="media/common.css" />
    <link rel="stylesheet" href="media/index.css" />
    <title>Long Standing Bug - Szymon Witamborski</title>
    <!-- work around IE not handling properly unknown tags -->
    <!-- suggested here: http://diveintohtml5.org/semantics.html -->
    <script>
      document.createElement("article");
      document.createElement("nav");
      document.createElement("aside");
      document.createElement("footer");
      document.createElement("date");
    </script>
  </head>
  <body>
    <div id="main_wrapper">
      <div id="header">
	<div id="sw">
	  S/W
	</div>
	<div id="cv">
	  <a href="swftwcv.pdf" alt="Hire me!">CV</a>
	</div>
	<div id="info">
	  Witam na&nbsp;stronie Szymona Witamborskiego. Jest on&nbsp;zainteresowany nowymi językami programowania, głównie Clojure. Poza tym od&nbsp;zawsze martwiły go&nbsp;tematy wokół tworzenia GUI. Ta&nbsp;strona opowiada o&nbsp;jego poczynaniach w&nbsp;w/w zagadnieniach.
	</div>
      </div>
      <aside id="menus">
	<nav id="misc" class="menu">
	  <ul>
	    <li><a href="atom.xml">Kanał Atom</a></li> 
	    <li><a href="archive.html">Archiwa</a></li>
	    <li><a href="info.html">Info</a></li>
	  </ul>
	</nav>
	<nav id="projects" class="menu">
	  Własne projekty:
	  <ul>
	    <li><a href="http://launchpad.net/makeblog">Makeblog</a></li>
	  </ul>
	</nav>
	<nav id="categories" class="menu">
	  Piszę o:
	  <ul>
	    <li>Tu pojawią się kategorie.</li>
	  </ul>
	</nav>
      </aside>
      <div id="latest">
	<div id="latest_text">Najnowszy wpis: <date>piątek, 03 wrzesień 2010</date></div>
	<article>
	  <h1>Błąd młodego parsownika</h1>
	  <p><em><strong>Parsownik</strong> &mdash; osoba pisząca parsery.</em><br />
<em>(Termin zawdzięczam mojemu bratu.)</em>
</p><p>Od pierwszego wpisu tutaj minęły 2 tygodnie. Najlepsze jest to, że
zacząłem pisać następny wpis już następnego dnia po wystartowaniu
bloga. Cały wpis powstał bez sprawdzania czy kompiluje się ładnie do
HTML-a. Po ukończeniu skompilował się, niestety źle. Bardzo
źle. Tagi przeplatały się w nieprawidłowy sposób, np. gwiazdka gdzieś
wcześniej w którymś paragrafie i gwiazdka gdzieś dalej w wypunktowaniu
powodowały otoczenie to tagiem &lt;b&gt;. Co dawało np. takie wyjście:
</p><pre>... &lt;p&gt; ... &lt;b&gt; ... &lt;/p&gt;
&lt;ul&gt; &lt;li&gt; ... &lt;/b&gt; ...
</pre><p>Mój parser działał ogólnie tak, że miał listę par: wyrażenie regularne
+ funkcja, która wywoływana była na tekście do którego zostało
dopasowane to wyrażenie. Aby zapobiec złemu przeplataniu się
tagów wyrażenia ozdobników (takich jak pogrubienie, pochylenie,
podkreślenie; do tego używam pojedynczych znaków, np:
<code>/asdf/</code> → <code>&lt;em&gt;asdf&lt;/em&gt;</code>)
stały się bardzo skomplikowane. Mam na myśli coś takiego
(<code>@</code> to odpowiednik dla znacznika <code>&lt;code&gt;</code>):
</p><pre>r"(?&lt;!&lt;|\w|[@])\@(?=\S)([^@]+)(?&lt;=\S)\@(?=\W)"
</pre><p>Nie jestem specjalistą od wyrażeń regularnych ale użycie ich wydawało
mi się bardzo obiecujące. Szczególnie łatwo było na początku ;).
</p><p>Przedstawione podejście miało poważne wady:
</p><ol>
<li>za każdym razem przetwarzany był cały tekst,</li>
<li>wyrażenia widziały go jako sam tekst a nie jako strukturę,</li>
<li>w praktyce dopuszczalne było przeplatanie się znaczników HTML j/w.</li>
</ol><p>Ogólnie całość sprawiała wrażenie jakby trzymała się na rzęsach :P.
Ciągłe dopasowywanie regexpów mogło się szybko skończyć kodem
spaghetti... Jednym słowem...
</p><h2>Porażka :D.</h2><p>Mogłem spodziewać się tego po przeczytaniu <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454">tego wątku na Stack Overflow</a>.
Dotyczył on parsowania HTML-a więc najpierw pomyślałem, że moja 
wymarzona składnia nie jest aż tak trudna do przetworzenia.
</p><p>Wróciłem do Stack Overflow jak mój parser zaczął nawalać...
</p><h2>Pyparsing</h2><blockquote><p>Have you tried using an XML parser instead?
&mdash; <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">Will</a>
</p></blockquote><p>Wow. To mi dało myślenia. Oczywiście nie chodziło o użycie parsera XML-a
ale śladem "gotowych, dobrze sprawdzonych rozwiązań" trafiłem na
<a href="http://pyparsing.wikispaces.com/">pyparsing</a>.
</p><p>Pyparsing jest (dla mnie, laika z tego tematu :P ) parserem dowolnie
zdefiniowanej gramatyki. Od np. <a href="http://www.antlr.org/">ANTLR-a</a> różni się
tym, że gramatykę definiuje się za pomocą wyrażeń w Pythonie (używając
zwykłych operatorów takich jak <code>+</code> czy <code>|</code>)
zamiast tradycyjnego <a href="http://pl.wikipedia.org/wiki/Notacja_EBNF">EBNF</a>.
</p><p>Idealnie dla mnie. Wystarczyło zrozumieć filozofię działania, przeczytać
<a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html">krótką i przystępną instrukcję</a>
oraz czasem zajrzeć do <a href="http://packages.python.org/pyparsing/">dokumentacji API</a>.
</p><h3>Prosty przykład</h3><p>Skoro jesteśmy przy moich <strong>pogrubieniach</strong> za pomocą gwiazdki i
<em>pochyleniach</em> za pomocą ukośnika, proponuję prosty, rekurencyjny przykład.
</p><p>Najpierw wersja nierekurencyjna:
</p><pre># -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( # tłumaczy się samo przez się
                         Word( # słowo (przynajmniej 1 znak) złożone z:
                               alphanums)) # litery i cyfry

bold = "*" + undecorated + "*"   # prawda,
italic = "/" + undecorated + "/" # że proste? :)

# metoda parseString() służy do... parsowania napisów
pprint(bold.parseString("*asdf*").asList())
pprint(italic.parseString("/qwer/").asList())
</pre><p>Wynikiem tego będzie:
</p><pre>['*', 'asdf', '*']
['/', 'qwer', '/']
</pre><p>Jak widać, pyparsing dzieli łańcuch na kawałki określone w gramatyce
(tokeny). Domyślnie omija też ew. białe znaki pomiędzy nimi.
</p><p>Rekurencyjny przykład będzie nieco dłuższy. Ponieważ Python nie pozwala
na używanie niezdefiniowanych symboli pyparsing załatwia to
klasą <code>Forward</code>, która umożliwia najpierw zadeklarowanie elementu
a później podanie jego definicji za pomocą operatora <code>&lt;&lt;</code>.
</p><pre># -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( Word(alphanums))

bold = Forward()
italic = Forward()

expression = OneOrMore( undecorated | bold | italic )

# Domyślnie wszystkie elementy odnalezione przez pyparsing
# zwracane są jako jednowymiarowa lista, Group stworzy
# listę zagnieżdżoną dla tego dopasowania
bold &lt;&lt; Group("*" + expression + "*")
italic &lt;&lt; Group("/" + expression + "/")

pprint(expression.parseString("""
czysty tekst
/krzywo/ *grubo*
/*krzywo grubo*/ */grubo krzywo/*
*grubo /krzywo i jeszcze raz *grubo*/*
""").asList())
</pre><p>Tym razem wyjście wygląda tak:
</p><pre>['czysty', 'tekst',        # czysty tekst
 ['/', 'krzywo', '/'],     # /krzywo/
 ['*', 'grubo', '*'],      # *grubo*
 ['/', ['*', 'krzywo', 'grubo', '*'], '/'], # /*krzywo grubo*/
 ['*', ['/', 'grubo', 'krzywo', '/'], '*'], # */grubo krzywo/*
 ['*', 'grubo',
  ['/', 'krzywo', 'i', 'jeszcze', 'raz',
   ['*', 'grubo', '*'],
   '/'],
  '*']]
</pre><p>Ostatni kawałek jest szczególnie ciekawy. Zostawiam go
do samodzielnego przeanalizowania :P. Dla mnie to była eureka,
która pozwoliła mi dalej popchnąć projekt :)
</p><p>Oba przykłady umieszczone są w <a href="input/blad-mlodego-parsownika.py">jednym pliku</a>.
Plik ten posiada jeszcze jeden cukierek dla osób wnikliwych ;).
Przedstawiony przykład jest uproszczeniem analogicznego kodu
z mojego <a href="http://bazaar.launchpad.net/~santamon/makeblog/trunk/annotate/head%3A/txt-to-html/txt-to-html.py">parsera</a>.
</p><p>Takie drzewko jak w ostatnim listingu możemy już dowolnie przetworzyć
manipulując listami, albo użyć metody <code>setParseAction(fn)</code> na każdym
zdefiniowanym elemencie gramatyki, gdzie <code>fn</code> to funkcja.
Jeśli <code>fn</code> zwróci jakąś wartość to element w drzewie zostanie
zastąpiony tą wartością.
</p><h2>Podsumowanie</h2><p>Nowy parser pozbawiony jest wad poprzedniego, przede wszystkim:
</p><ol>
<li>działa,</li>
<li>jest bardziej przewidywalny,</li>
<li>kod jest przejrzystszy,</li>
<li>jest łatwiej rozszerzalny.</li>
</ol><p>Polecam przyjrzeć się <a href="http://pyparsing.wikispaces.com/">pyparsing</a> jeśli
mamy potrzebę/chęć przetworzenia jakiegoś tekstu i piszemy
w Pythonie. Jeszcze raz podaję adres do <a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html">samouczka</a>
oraz do <a href="http://packages.python.org/pyparsing/">dokumentacji API</a>.
Pyparsing ma bardzo fajną licencję (<a href="http://www.opensource.org/licenses/mit-license.php">MIT</a>, "róbta co chceta ale pochwalcie się od kogo ściągaliście" :P ) i jest dość popularne, co znaczy, że powinna być dostępna w
Twojej Ulubionej Dystrybucji ;).
</p>
	</article>
      </div>
      <footer>
	&copy; 2010 Szymon Witamborski
      </footer>
    </div>
  </body>
</html>
