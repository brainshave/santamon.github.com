<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="media/bug-inv.ico" type="image/x-icon" />
    <link rel="stylesheet" href="media/fonts.css" />
    <link rel="stylesheet" href="media/makeblog.css" />
    <link rel="stylesheet" href="media/common.css" />
    <link rel="stylesheet" href="media/article.css" />
    <title>Błąd młodego parsownika</title>
    <!-- work around IE not handling properly unknown tags -->
    <!-- suggested here: http://diveintohtml5.org/semantics.html -->
    <script>
      document.createElement("article");
      document.createElement("nav");
      document.createElement("aside");
      document.createElement("footer");
      document.createElement("date");
    </script>
  </head>
  <body>
    <div id="main_wrapper">
      <div id="header">
	<div id="sw"><a href="index.html">S/W</a></div>
	<nav id="menu">
	  <a href="archive.html">Archiwa</a>,
	  <a href="info.html">Info</a>
	</nav>
      </div>
      <div id="latest">
	<time id="latest_text">czwartek, 02 wrzesień 2010</time>
	<article>
	  <h1>Błąd młodego parsownika</h1>
	  <p><em><strong>Parsownik</strong> &mdash; osoba pisząca parsery.</em><br />
<em>(Termin zawdzięczam mojemu bratu.)</em>
</p><p>Od pierwszego wpisu tutaj minęły 2 tygodnie. Najlepsze w tym jest to, że
zacząłem pisać następny wpis już następnego dnia po wystartowaniu
bloga. Cały wpis powstał bez sprawdzania czy kompiluje się ładnie do
HTML-a. Po ukończeniu skompilował się. Niestety źle. Bardzo
źle. Tagi przeplatały się w nieprawidłowy sposób, np. gwiazdka gdzieś
wcześniej w którymś paragrafie i gwiazdka gdzieś dalej w wypunktowaniu
powodowały otoczenie to tagiem &lt;b&gt;.
</p><p>Mój parser działał ogólnie tak, że miał listę par: wyrażenie regularne
+ funkcja, która wywoływana była na tekście do którego zostało
dopasowane to wyrażenie. Ekstremalne znaczenie miała tutaj kolejność
w jakim wyrażenia te były ułożone. Aby zapobiec złemu przeplataniu się
tagów wyrażenia ozdobników (takich jak pogrubienie, pochylenie,
podkreślenie; do tego używam pojedynczych znaków, np:
<code>/asdf/</code> → <code>&lt;em&gt;asdf&lt;/em&gt;</code>)
stały się bardzo skomplikowane. Mam na myśli coś takiego
(<code>@</code> to znacznik):
</p><pre>r"(?&lt;!&lt;|\w|[@])\@(?=\S)([^@]+)(?&lt;=\S)\@(?=\W)"
</pre><p>Nie jestem specjalistą od wyrażeń regularnych ale użycie ich wydawało
mi się bardzo obiecujące. Szczególnie łatwo było na początku ;).
</p><p>Przedstawione podejście miało poważne wady:
</p><ol>
<li>za każdym razem przetwarzany był cały tekst,</li>
<li>wyrażenia widziały go jako sam tekst nie jako strukturę,</li>
<li>w praktyce dopuszczalne było przeplatanie się znaczników HTML j/w.</li>
</ol><p>Ogólnie całość sprawiała wrażenie jakby trzymała się na rzęsach :P.
Ciągłe dopasowywanie regexpów mogło się szybko skończyć kodem
spaghetti... Jednym słowem
</p><h2>Fail.</h2><p>W sumie spodziewałem się tego po przeczytaniu <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454">tego wątku na Stack Overflow</a>.
Dotyczył on parsowania HTML-a więc najpierw pomyślałem, że moja 
wymarzona składnia nie jest aż tak trudna do przetworzenia.
</p><p>Wróciłem do Stack Overflow jak mój parser zaczął nawalać...
</p><h2>Pyparsing</h2><blockquote><p>Have you tried using an XML parser instead?
&mdash; <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">Will</a>
</p></blockquote><p>Wow. To mi dało myślenia. Oczywiście nie chodziło o użycie parsera XML-a
ale śladem "gotowych, dobrze sprawdzonych rozwiązań" trafiłem na
<a href="http://pyparsing.wikispaces.com/">pyparsing</a>.
</p><p>Pyparsing jest (dla mnie, laika z tego tematu :P ) parserem dowolnie
zdefiniowanej gramatyki. Od np. <a href="http://www.antlr.org/">ANTLR-a</a> różni się
tym, że gramatykę definiuje się za pomocą wyrażeń w Pythonie (używając
zwykłych operatorów takich jak <code>+</code> czy <code>|</code>)
zamiast tradycyjnego <a href="http://pl.wikipedia.org/wiki/Notacja_EBNF">EBNF</a>.
</p><p>Idealnie dla mnie. Wystarczyło zrozumieć filozofię działania, przeczytać
<a href="http://pyparsing.svn.sourceforge.net/viewvc/pyparsing/src/HowToUsePyparsing.html">krótką i przystępną instrukcję</a>
oraz czasem zajrzeć do <a href="http://packages.python.org/pyparsing/">dokumentacji API</a>.
</p><h3>Prosty przykład</h3><p>Skoro jesteśmy przy moich <strong>pogrubieniach</strong> za pomocą gwiazdki i
<em>pochyleniach</em> za pomocą ukośnika, proponuję prosty, rekurencyjny przykład.
</p><p>Najpierw wersja nierekurencyjna:
</p><pre># -*- coding: utf-8 -*-
from pyparsing import *
from pprint import pprint

undecorated = OneOrMore( # tłumaczy się samo przez się
                         Word( # słowo (przynajmniej 1 znak) złożone z:
                               alphanums)) # litery i cyfry

bold = "*" + undecorated + "*"   # prawda,
italic = "/" + undecorated + "/" # że proste? :)

# metoda parseString() służy do... parsowania napisów
pprint(bold.parseString("*asdf*").asList())
pprint(italic.parseString("/qwer/").asList())
</pre><p>Wynikiem tego będzie:
</p><pre>['*', 'asdf', '*']
['/', 'qwer', '/']
</pre><p>Rekurencyjny przykład będzie nieco dłuższy. Ponieważ Python nie pozwala
na używanie niezdefiniowanych symboli, pyparsing załatwia to
klasą <code>Forward</code>, która umożliwia najpierw zdefiniowanie elementu
a później podanie jego definicji za pomocą operatora <code>&lt;&lt;</code>.
</p><h3>Filozofia działania</h3><p>Zamiast parsowania tekstu dla każdego wyrażenia od początku,
pyparsing przetworzy plik tylko raz. Haczyk jest w tym, że
można tak zdefiniować 
</p>
	</article>
      </div>
      <footer>
	&copy; 2010 Szymon Witamborski
      </footer>
    </div>
  </body>
</html>
